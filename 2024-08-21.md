# ETSF10, 2024-08-21

## Question 1

**Two hosts are connected with a point to point link. The data rate of the link is 100 Mbit/s and data is sent continuously. The minimum receive window size (so that the receive buffer does not run the risk of overflowing) is 10.000 byte. What is the RTT of the link? Show your calculation.**

The receive window size _W_ must be at least as large as the _Bandwidth-Delay Product_ (BDP) to prevent overflow. The BDP is the product of the data rate and the RTT.

> W = R × RTT

Solving for RTT:

> RTT = W / R = 80000 / 100000000 = 0.0008

Answer: 0.8ms

## Question 2

**A router has the following forwarding table for the same output port:**

| Network ID | Net mask |
| ---------- | -------- |
| 10.0.0.128 | /25      |
| 10.0.0.0   | /25      |
| 10.0.1.0   | /24      |
| 10.0.4.0   | /23      |
| 10.0.2.0   | /23      |

**First aggregate the table as much as possible and then answer the following question.**

**What is the id of the network to which the adress 10.0.1.14 belongs?**

_Answer in the example form 192.168.100.0 /24 or 192.168.100.0/255.255.254.0_

> The first entry in the original routing table will match with IP addresses of the type `00001010.00000000.00000000.1XXXXXXXX`. The second one, `00001010.00000000.00000000.0XXXXXXX`. These two entries can therefore be merged into just one entry covering that entire range: `00001010.00000000.00000000.XXXXXXXX`. This means only the first _24_ bits will identify the subnet, so the subnet mask of the merged entry is `/24`. With this merge, **we do not lose any coverage**.

| Network ID | Net mask |
| ---------- | -------- |
| 10.0.0.0   | /24      |
| 10.0.1.0   | /24      |
| 10.0.4.0   | /23      |
| 10.0.2.0   | /23      |

> Now we have two entries with the subnet mask `/24`. In binary, the IDs are `00001010.00000000.00000000.XXXXXXXX` and `00001010.00000000.00000001.XXXXXXXX` respectively. By decreasing the subnet mask number to `23`, we can merge these two into a new entry. We get `10.0.0.0/23`.

| Network ID | Net mask |
| ---------- | -------- |
| 10.0.0.0   | /23      |
| 10.0.4.0   | /23      |
| 10.0.2.0   | /23      |

> We can finally merge `10.0.2.0/23` with our new `10.0.0.23/23`. The result will be an entry with the network ID `10.0.0.0`, but with a net mask of only `/22`. That way, It'll cover all addresses `00001010.00000000.000000XX.XXXXXXXX`.

Final aggregated table:

| Network ID | Net mask | Coverage                            |
| ---------- | -------- | ----------------------------------- |
| 10.0.0.0   | /22      | 00001010.00000000.000000XX.XXXXXXXX |
| 10.0.4.0   | /23      | 00001010.00000000.0000010X.XXXXXXXX |

As for the question, the IP address `10.0.1.14` in binary looks like `00001010.00000000.00000001.00001110`. As we can see, the only prefix match is with our first entry, so the **network ID is therefore `10.0.0.0/22`**.

## Question 3

**Router X has the following routing table:**

| Network | Hops | Next hop |
| ------- | ---- | -------- |
| Net2    | 6    | A        |
| Net3    | 4    | C        |
| Net4    | 3    | A        |
| Net6    | 2    | C        |
| Net7    | 3    | B        |

**It receives the following RIP update message from a neighbour D:**

| Network | Hops |
| ------- | ---- |
| Net2    | 1    |
| Net4    | 6    |
| Net5    | 1    |
| Net6    | 1    |
| Net7    | 5    |

**Fill in the following table with the new routing table X has and will advertise after the update. If a field is not applicable/not used fill in “N/A”.**

> The strategy is to compare the current paths we have with those we could create via our neighbour `D`. We should note however, that moving to `D` also means hopping once. In our case, we could create an entry to `Net5` and update our path to `Net2`.

| Network | Hops | Next hop |
| ------- | ---- | -------- |
| Net1    | N/A  | N/A      |
| Net2    | 2    | D        |
| Net3    | 4    | C        |
| Net4    | 3    | A        |
| Net5    | 2    | D        |
| Net6    | 2    | C        |
| Net7    | 3    | B        |

## Question 4

![Image of network](./images/2024-08-21-q4.png)

**Given the figure above. The host addresses are given below:**

`B = 192.168.1.11`\
`C = 192.168.1.12`\
`D = 192.168.1.13`

`X = 210.10.3.14`\
`Y = 13.85.34.123`\
`Z = 145.234.10.73`

**`N` is a router with an address translator with a single global external address.**

**Add partial entries to router `N`’s _NAPT table_ as the following events take place in numbered order in the sub questions below.**

_For known port numbers, insert the actual number and for port numbers taken from a list of available but non-allocated port numbers use “unused”. If an event cannot take place write “N/A”. Internal refers to the private network and external to the NAT’s public network side_

1. **NetAdmin configures port forwarding for HTTP to B**

> The internal IP address is the one used within the LAN (to the left of the router `N` in the picture). In our case, it'll simply be the IP address of `B`: `192.168.1.11`. The HTTP protocol defaults to port `80`, so the internal port will therefore be set to `80`. Port `80` is not in use externally, so it'll be set as the external port as well.

Internal IP Address: `192.168.1.11`\
Internal port: `80`\
External port: `80`

2. **Y opens up an SMTP connection to D**

> Here, an external host attempts to initiate a SMTP connection to host `D`. SMTP uses port `25`, for which we do not have a port forwarding rule for. From an external point of view, `D`'s IP address cannot be known as it is behind `N`.

N/A

3. **B opens up a HTTP connection to Z**

> The explanation I, with my loyal LLM instance, came to find was that when `B` tries to initiate a new HTTP connection with an external host (`Z`), a random unused port is selected internally and another random unused port is selected externally. In the new entry, they are mapped together with the internal IP address set to, you guessed it, `B`'s address `192.168.1.11`. Note that the internal and external port numbers don't have to be equal. They are randomly selected independantly and are mapped together with this new NAPT entry.

Internal IP Address: `192.168.1.11`\
Internal port: `unused`\
External port: `unused`

4. **Z opens up a HTTP connection to N**

> Here, an external host opens a HTTP connection to our router, `N`. By default, the port used from the external request will be `80`, since it's HTTP. Because of event 1, our router does have a port fortwarding rule for that port! This means that **no new entry is created**, but the traffic is directed to the IP address of host `B`, internal port `80`.

No new entry, but traffic directed (according to previously configured port forwarding rule) to `192.168.1.11:80` internally. External port: `80` (HTTP).

5. **X opens up a HTTP connection to N**

> Same logic as previous event applies here.

No new entry, but traffic directed (according to previously configured port forwarding rule) to `192.168.1.11:80` internally. External port: `80` (HTTP).

## Question 5

**A client is sending a message to a server using TCP. The following words are sent across the network (disregard header information etc.):**

`0101001101100110; 0111010010110100; 0000110111000001`

**Calculate the checksum TCP adds to the message to be sent. Provide your calculation below.**

> To calculate the checksum, we must sum all words, wrapping around potential overflows, then taking the ones complement.

```
   1111111111  1
   0101001101100110
   0111010010110100
+  0000110111000001
-------------------
   1101010111011011
```

> This time we didn't encounter any overflow, which is lucky. In other cases, overflow would be handled by shifting the overflow to the right, then adding it again to our number.

Ones complement of sum (flipping ones and zeros): `0010101000100100` <- checksum!

**Now assume that the client sent the following bit sequence: 01011101 111100010 and the checksum that was sent was 00110010 00001101, was the transmitted message received correctly? Show your calculation below.**

> This question most likely has a mistake in it, since the bit sequence is of length `17`. In internet checksumming they should always be `16`.

## Question 6

## Question 8

**Suppose an 11Mbps WLAN is transmitting 64 byte frames back to back (without waiting time in-between) over a radio channel with a bit error rate of 10<sup>-7</sup> . How many frames per second will contain errors on average? Show your calculations.**

> I will start by converting the frame size to bits.

Frame size = 8 * 64 = 512 bits

> Now my method will be to figure out what the probability is for one frame to be corrupted is, then multiply that with how many frames fit within one second.

Chances of a not corrupted packet = (1 - 10<sup>-7</sup>)^512

Chances of corrupted packet is therefore 1 minus that.

Packets per second = 11 000 000 / 512 = 21484.375

Answer: 